
!
!                Parallel Sparse BLAS  version 3.5
!      (C) Copyright 2006-2018
!        Salvatore Filippone
!        Alfredo Buttari
!
!    Redistribution and use in source and binary forms, with or without
!    modification, are permitted provided that the following conditions
!    are met:
!      1. Redistributions of source code must retain the above copyright
!         notice, this list of conditions and the following disclaimer.
!      2. Redistributions in binary form must reproduce the above copyright
!         notice, this list of conditions, and the following disclaimer in the
!         documentation and/or other materials provided with the distribution.
!      3. The name of the PSBLAS group or the names of its contributors may
!         not be used to endorse or promote products derived from this
!         software without specific written permission.
!
!    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
!    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
!    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
!    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE PSBLAS GROUP OR ITS CONTRIBUTORS
!    BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
!    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
!    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
!    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
!    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
!    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
!    POSSIBILITY OF SUCH DAMAGE.
!
!
!
! package: psb_@X@_csr_mat_mod
!
! This module contains the definition of the psb_@X@_csr_sparse_mat type
! which implements an actual storage format (the CSR in this case) for
! a sparse matrix as well as the related methods (those who are
! specific to the type and could not be defined higher in the
! hierarchy). We are at the bottom level of the inheritance chain.
!
! Please refere to psb_@X@_base_mat_mod for a detailed description
! of the various methods, and to psb_@X@_csr_impl for implementation details.
!
module psb_@X@_csr_mat_mod

  use psb_@X@_base_mat_mod

  !> \namespace  psb_base_mod  \class  psb_@X@_csr_sparse_mat
  !! \extends psb_@X@_base_mat_mod::psb_@X@_base_sparse_mat
  !!
  !! psb_@X@_csr_sparse_mat type and the related methods.
  !! This is a very common storage type, and is the default for assembled
  !! matrices in our library
  type, extends(psb_@X@_base_sparse_mat) :: psb_@X@_csr_sparse_mat

    !> Pointers to beginning of rows in JA and VAL.
    integer(@IXKIND@), allocatable :: irp(:)
    !> Column indices.
    integer(@IXKIND@), allocatable :: ja(:)
    !> Coefficient values.
    @TYPE@(@FKIND@), allocatable :: val(:)

  contains
    procedure, pass(a) :: is_by_rows  => @X@_csr_is_by_rows
    procedure, pass(a) :: get_size    => @X@_csr_get_size
    procedure, pass(a) :: get_nzeros  => @X@_csr_get_nzeros
    procedure, nopass  :: get_fmt     => @X@_csr_get_fmt
    procedure, pass(a) :: sizeof      => @X@_csr_sizeof
    procedure, pass(a) :: csmm        => psb_@X@_csr_csmm
    procedure, pass(a) :: csmv        => psb_@X@_csr_csmv
    procedure, pass(a) :: inner_cssm  => psb_@X@_csr_cssm
    procedure, pass(a) :: inner_cssv  => psb_@X@_csr_cssv
    procedure, pass(a) :: scals       => psb_@X@_csr_scals
    procedure, pass(a) :: scalv       => psb_@X@_csr_scal
    procedure, pass(a) :: maxval      => psb_@X@_csr_maxval
    procedure, pass(a) :: spnmi       => psb_@X@_csr_csnmi
    procedure, pass(a) :: rowsum      => psb_@X@_csr_rowsum
    procedure, pass(a) :: arwsum      => psb_@X@_csr_arwsum
    procedure, pass(a) :: colsum      => psb_@X@_csr_colsum
    procedure, pass(a) :: aclsum      => psb_@X@_csr_aclsum
    procedure, pass(a) :: reallocate_nz => psb_@X@_csr_reallocate_nz
    procedure, pass(a) :: allocate_mnnz => psb_@X@_csr_allocate_mnnz
    procedure, pass(a) :: tril          => psb_@X@_csr_tril
    procedure, pass(a) :: triu          => psb_@X@_csr_triu
    procedure, pass(a) :: cp_to_coo   => psb_@X@_cp_csr_to_coo
    procedure, pass(a) :: cp_from_coo => psb_@X@_cp_csr_from_coo
    procedure, pass(a) :: cp_to_fmt   => psb_@X@_cp_csr_to_fmt
    procedure, pass(a) :: cp_from_fmt => psb_@X@_cp_csr_from_fmt
    procedure, pass(a) :: mv_to_coo   => psb_@X@_mv_csr_to_coo
    procedure, pass(a) :: mv_from_coo => psb_@X@_mv_csr_from_coo
    procedure, pass(a) :: mv_to_fmt   => psb_@X@_mv_csr_to_fmt
    procedure, pass(a) :: mv_from_fmt => psb_@X@_mv_csr_from_fmt
    procedure, pass(a) :: clean_zeros => psb_@X@_csr_clean_zeros
    procedure, pass(a) :: csput_a     => psb_@X@_csr_csput_a
    procedure, pass(a) :: get_diag    => psb_@X@_csr_get_diag
    procedure, pass(a) :: csgetptn    => psb_@X@_csr_csgetptn
    procedure, pass(a) :: csgetrow   => psb_@X@_csr_csgetrow
    procedure, pass(a) :: get_nz_row  => @X@_csr_get_nz_row
    procedure, pass(a) :: reinit      => psb_@X@_csr_reinit
    procedure, pass(a) :: trim        => psb_@X@_csr_trim
    procedure, pass(a) :: print       => psb_@X@_csr_print
    procedure, pass(a) :: free        => @X@_csr_free
    procedure, pass(a) :: mold        => psb_@X@_csr_mold

  end type psb_@X@_csr_sparse_mat

  private :: @X@_csr_get_nzeros, @X@_csr_free,  @X@_csr_get_fmt, &
       & @X@_csr_get_size, @X@_csr_sizeof, @X@_csr_get_nz_row, &
       & @X@_csr_is_by_rows

  !> \memberof psb_@X@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_reallocate_nz
  interface
    subroutine  psb_@X@_csr_reallocate_nz(nz,a)
      import
      integer(@IXKIND@), intent(in) :: nz
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
    end subroutine psb_@X@_csr_reallocate_nz
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_reinit
  interface
    subroutine psb_@X@_csr_reinit(a,clear)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      logical, intent(in), optional :: clear
    end subroutine psb_@X@_csr_reinit
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_trim
  interface
    subroutine  psb_@X@_csr_trim(a)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
    end subroutine psb_@X@_csr_trim
  end interface


  !> \memberof psb_@X@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_mold
  interface
    subroutine psb_@X@_csr_mold(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(in)                  :: a
      class(psb_@X@_base_sparse_mat), intent(inout), allocatable :: b
      integer(psb_ipk_), intent(out)                           :: info
    end subroutine psb_@X@_csr_mold
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_allocate_mnnz
  interface
    subroutine  psb_@X@_csr_allocate_mnnz(m,n,a,nz)
      import
      integer(@IXKIND@), intent(in) :: m,n
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      integer(@IXKIND@), intent(in), optional :: nz
    end subroutine psb_@X@_csr_allocate_mnnz
  end interface


  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_print
  interface
    subroutine psb_@X@_csr_print(iout,a,iv,head,ivr,ivc)
      import
      integer(psb_ipk_), intent(in)               :: iout
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      integer(@LXKIND@), intent(in), optional     :: iv(:)
      character(len=*), optional        :: head
      integer(@LXKIND@), intent(in), optional     :: ivr(:), ivc(:)
    end subroutine psb_@X@_csr_print
  end interface
  !
  !> Function  tril:
  !! \memberof  psb_@X@_base_sparse_mat
  !! \brief  Copy the lower triangle, i.e. all entries
  !!         A(I,J) such that J-I <= DIAG
  !!         default value is DIAG=0, i.e. lower triangle up to
  !!         the main diagonal.
  !!         DIAG=-1 means copy the strictly lower triangle
  !!         DIAG= 1 means copy the lower triangle plus the first diagonal
  !!                 of the upper triangle.
  !!         Moreover, apply a clipping by copying entries A(I,J) only if
  !!         IMIN<=I<=IMAX
  !!         JMIN<=J<=JMAX
  !!
  !!  \param l     the output (sub)matrix
  !!  \param info  return code
  !!  \param diag [0] the last diagonal (J-I) to be considered.
  !!  \param imin [1] the minimum row index we are interested in
  !!  \param imax [a\%get_nrows()] the minimum row index we are interested in
  !!  \param jmin [1] minimum col index
  !!  \param jmax [a\%get_ncols()] maximum col index
  !!  \param iren(:) [none] an array to return renumbered indices (iren(ia(:)),iren(ja(:))
  !!  \param rscale [false] map [min(ia(:)):max(ia(:))] onto [1:max(ia(:))-min(ia(:))+1]
  !!  \param cscale [false] map [min(ja(:)):max(ja(:))] onto [1:max(ja(:))-min(ja(:))+1]
  !!          ( iren cannot be specified with rscale/cscale)
  !!  \param append [false] append to ia,ja
  !!  \param nzin [none]  if append, then first new entry should go in entry nzin+1
  !!  \param u  [none]  copy of the complementary triangle
  !!
  !
  interface
    subroutine psb_@X@_csr_tril(a,l,info,diag,imin,imax,&
         & jmin,jmax,rscale,cscale,u)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      class(psb_@X@_coo_sparse_mat), intent(out) :: l
      integer(psb_ipk_),intent(out)              :: info
      integer(@IXKIND@), intent(in), optional    :: diag,imin,imax,jmin,jmax
      logical, intent(in), optional              :: rscale,cscale
      class(psb_@X@_coo_sparse_mat), optional, intent(out) :: u
    end subroutine psb_@X@_csr_tril
  end interface

  !
  !> Function  triu:
  !! \memberof  psb_@X@_csr_sparse_mat
  !! \brief  Copy the upper triangle, i.e. all entries
  !!         A(I,J) such that DIAG <= J-I
  !!         default value is DIAG=0, i.e. upper triangle from
  !!         the main diagonal up.
  !!         DIAG= 1 means copy the strictly upper triangle
  !!         DIAG=-1 means copy the upper triangle plus the first diagonal
  !!                 of the lower triangle.
  !!         Moreover, apply a clipping by copying entries A(I,J) only if
  !!         IMIN<=I<=IMAX
  !!         JMIN<=J<=JMAX
  !!         Optionally copies the lower triangle at the same time
  !!
  !!  \param u     the output (sub)matrix
  !!  \param info  return code
  !!  \param diag [0] the last diagonal (J-I) to be considered.
  !!  \param imin [1] the minimum row index we are interested in
  !!  \param imax [a\%get_nrows()] the minimum row index we are interested in
  !!  \param jmin [1] minimum col index
  !!  \param jmax [a\%get_ncols()] maximum col index
  !!  \param iren(:) [none] an array to return renumbered indices (iren(ia(:)),iren(ja(:))
  !!  \param rscale [false] map [min(ia(:)):max(ia(:))] onto [1:max(ia(:))-min(ia(:))+1]
  !!  \param cscale [false] map [min(ja(:)):max(ja(:))] onto [1:max(ja(:))-min(ja(:))+1]
  !!          ( iren cannot be specified with rscale/cscale)
  !!  \param append [false] append to ia,ja
  !!  \param nzin [none]  if append, then first new entry should go in entry nzin+1
  !!  \param l  [none]  copy of the complementary triangle
  !!
  !
  interface
    subroutine psb_@X@_csr_triu(a,u,info,diag,imin,imax,&
         & jmin,jmax,rscale,cscale,l)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      class(psb_@X@_coo_sparse_mat), intent(out) :: u
      integer(psb_ipk_),intent(out)              :: info
      integer(@IXKIND@), intent(in), optional    :: diag,imin,imax,jmin,jmax
      logical, intent(in), optional              :: rscale,cscale
      class(psb_@X@_coo_sparse_mat), optional, intent(out) :: l
    end subroutine psb_@X@_csr_triu
  end interface

  !
  !>
  !! \memberof  psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_clean_zeros
  !
  interface
    subroutine  psb_@X@_csr_clean_zeros(a, info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      integer(psb_ipk_), intent(out)              :: info
    end subroutine psb_@X@_csr_clean_zeros
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_cp_to_coo
  interface
    subroutine psb_@X@_cp_csr_to_coo(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      class(psb_@X@_coo_sparse_mat), intent(inout) :: b
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@X@_cp_csr_to_coo
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_cp_from_coo
  interface
    subroutine psb_@X@_cp_csr_from_coo(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      class(psb_@X@_coo_sparse_mat), intent(in)    :: b
      integer(psb_ipk_), intent(out)               :: info
    end subroutine psb_@X@_cp_csr_from_coo
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_cp_to_fmt
  interface
    subroutine psb_@X@_cp_csr_to_fmt(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(in)   :: a
      class(psb_@X@_base_sparse_mat), intent(inout) :: b
      integer(psb_ipk_), intent(out)                       :: info
    end subroutine psb_@X@_cp_csr_to_fmt
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_cp_from_fmt
  interface
    subroutine psb_@X@_cp_csr_from_fmt(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      class(psb_@X@_base_sparse_mat), intent(in)   :: b
      integer(psb_ipk_), intent(out)                        :: info
    end subroutine psb_@X@_cp_csr_from_fmt
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_mv_to_coo
  interface
    subroutine psb_@X@_mv_csr_to_coo(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      class(psb_@X@_coo_sparse_mat), intent(inout)   :: b
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@X@_mv_csr_to_coo
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_mv_from_coo
  interface
    subroutine psb_@X@_mv_csr_from_coo(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      class(psb_@X@_coo_sparse_mat), intent(inout) :: b
      integer(psb_ipk_), intent(out)                        :: info
    end subroutine psb_@X@_mv_csr_from_coo
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_mv_to_fmt
  interface
    subroutine psb_@X@_mv_csr_to_fmt(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      class(psb_@X@_base_sparse_mat), intent(inout)  :: b
      integer(psb_ipk_), intent(out)                        :: info
    end subroutine psb_@X@_mv_csr_to_fmt
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_mv_from_fmt
  interface
    subroutine psb_@X@_mv_csr_from_fmt(a,b,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout)  :: a
      class(psb_@X@_base_sparse_mat), intent(inout) :: b
      integer(psb_ipk_), intent(out)                         :: info
    end subroutine psb_@X@_mv_csr_from_fmt
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_cp_from
  interface
    subroutine psb_@X@_csr_cp_from(a,b)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      type(psb_@X@_csr_sparse_mat), intent(in)   :: b
    end subroutine psb_@X@_csr_cp_from
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_mv_from
  interface
    subroutine psb_@X@_csr_mv_from(a,b)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout)  :: a
      type(psb_@X@_csr_sparse_mat), intent(inout) :: b
    end subroutine psb_@X@_csr_mv_from
  end interface


  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_csput_a
  interface
    subroutine psb_@X@_csr_csput_a(nz,ia,ja,val,a,imin,imax,jmin,jmax,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      @TYPE@(@FKIND@), intent(in)      :: val(:)
      integer(@IXKIND@), intent(in)             :: nz,ia(:), ja(:),&
           &  imin,imax,jmin,jmax
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@X@_csr_csput_a
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_base_mat_mod::psb_base_csgetptn
  interface
    subroutine psb_@X@_csr_csgetptn(imin,imax,a,nz,ia,ja,info,&
         & jmin,jmax,iren,append,nzin,rscale,cscale)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      integer(@IXKIND@), intent(in)                  :: imin,imax
      integer(@IXKIND@), intent(out)                 :: nz
      integer(@IXKIND@), allocatable, intent(inout)  :: ia(:), ja(:)
      integer(psb_ipk_),intent(out)                  :: info
      logical, intent(in), optional        :: append
      integer(@IXKIND@), intent(in), optional        :: iren(:)
      integer(@IXKIND@), intent(in), optional        :: jmin,jmax, nzin
      logical, intent(in), optional        :: rscale,cscale
    end subroutine psb_@X@_csr_csgetptn
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_csgetrow
  interface
    subroutine psb_@X@_csr_csgetrow(imin,imax,a,nz,ia,ja,val,info,&
         & jmin,jmax,iren,append,nzin,rscale,cscale,chksz)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      integer(@IXKIND@), intent(in)                  :: imin,imax
      integer(@IXKIND@), intent(out)                 :: nz
      integer(@IXKIND@), allocatable, intent(inout)  :: ia(:), ja(:)
      @TYPE@(@FKIND@), allocatable,  intent(inout)    :: val(:)
      integer(psb_ipk_),intent(out)                  :: info
      logical, intent(in), optional        :: append
      integer(@IXKIND@), intent(in), optional        :: iren(:)
      integer(@IXKIND@), intent(in), optional        :: jmin,jmax, nzin
      logical, intent(in), optional        :: rscale,cscale,chksz
    end subroutine psb_@X@_csr_csgetrow
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_cssv
  interface
    subroutine psb_@X@_csr_cssv(alpha,a,x,beta,y,info,trans)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(in)          :: alpha, beta, x(:)
      @TYPE@(@FKIND@), intent(inout)       :: y(:)
      integer(psb_ipk_), intent(out)                :: info
      character, optional, intent(in)     :: trans
    end subroutine psb_@X@_csr_cssv
  end interface
  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_cssm
  interface
    subroutine psb_@X@_csr_cssm(alpha,a,x,beta,y,info,trans)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(in)          :: alpha, beta, x(:,:)
      @TYPE@(@FKIND@), intent(inout)       :: y(:,:)
      integer(psb_ipk_), intent(out)                :: info
      character, optional, intent(in)     :: trans
    end subroutine psb_@X@_csr_cssm
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_csmv
  interface
    subroutine psb_@X@_csr_csmv(alpha,a,x,beta,y,info,trans)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(in)          :: alpha, beta, x(:)
      @TYPE@(@FKIND@), intent(inout)       :: y(:)
      integer(psb_ipk_), intent(out)                :: info
      character, optional, intent(in)     :: trans
    end subroutine psb_@X@_csr_csmv
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_csmm
  interface
    subroutine psb_@X@_csr_csmm(alpha,a,x,beta,y,info,trans)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(in)          :: alpha, beta, x(:,:)
      @TYPE@(@FKIND@), intent(inout)       :: y(:,:)
      integer(psb_ipk_), intent(out)                :: info
      character, optional, intent(in)     :: trans
    end subroutine psb_@X@_csr_csmm
  end interface


  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_maxval
  interface
    function psb_@X@_csr_maxval(a) result(res)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @RTYPE@(@FKIND@)         :: res
    end function psb_@X@_csr_maxval
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_csnmi
  interface
    function psb_@X@_csr_csnmi(a) result(res)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @RTYPE@(@FKIND@)         :: res
    end function psb_@X@_csr_csnmi
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_rowsum
  interface
    subroutine psb_@X@_csr_rowsum(d,a)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(out)              :: d(:)
    end subroutine psb_@X@_csr_rowsum
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_arwsum
  interface
    subroutine psb_@X@_csr_arwsum(d,a)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @RTYPE@(@FKIND@), intent(out)              :: d(:)
    end subroutine psb_@X@_csr_arwsum
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_colsum
  interface
    subroutine psb_@X@_csr_colsum(d,a)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(out)              :: d(:)
    end subroutine psb_@X@_csr_colsum
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_aclsum
  interface
    subroutine psb_@X@_csr_aclsum(d,a)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @RTYPE@(@FKIND@), intent(out)              :: d(:)
    end subroutine psb_@X@_csr_aclsum
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_get_diag
  interface
    subroutine psb_@X@_csr_get_diag(a,d,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(out)     :: d(:)
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@X@_csr_get_diag
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_scal
  interface
    subroutine psb_@X@_csr_scal(d,a,info,side)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      @TYPE@(@FKIND@), intent(in)      :: d(:)
      integer(psb_ipk_), intent(out)            :: info
      character, intent(in), optional :: side
    end subroutine psb_@X@_csr_scal
  end interface

  !> \memberof psb_@X@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@X@_base_scals
  interface
    subroutine psb_@X@_csr_scals(d,a,info)
      import
      class(psb_@X@_csr_sparse_mat), intent(inout) :: a
      @TYPE@(@FKIND@), intent(in)      :: d
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@X@_csr_scals
  end interface

    !> \namespace  psb_base_mod  \class  psb_@LX@_csr_sparse_mat
  !! \extends psb_@LX@_base_mat_mod::psb_@LX@_base_sparse_mat
  !!
  !! psb_@LX@_csr_sparse_mat type and the related methods.
  !! This is a very common storage type, and is the default for assembled
  !! matrices in our library
  type, extends(psb_@LX@_base_sparse_mat) :: psb_@LX@_csr_sparse_mat

    !> Pointers to beginning of rows in JA and VAL.
    integer(@LXKIND@), allocatable :: irp(:)
    !> Column indices.
    integer(@LXKIND@), allocatable :: ja(:)
    !> Coefficient values.
    @TYPE@(@FKIND@), allocatable :: val(:)

  contains
    procedure, pass(a) :: is_by_rows  => @LX@_csr_is_by_rows
    procedure, pass(a) :: get_size    => @LX@_csr_get_size
    procedure, pass(a) :: get_nzeros  => @LX@_csr_get_nzeros
    procedure, nopass  :: get_fmt     => @LX@_csr_get_fmt
    procedure, pass(a) :: sizeof      => @LX@_csr_sizeof
    procedure, pass(a) :: reallocate_nz => psb_@LX@_csr_reallocate_nz
    procedure, pass(a) :: allocate_mnnz => psb_@LX@_csr_allocate_mnnz
    procedure, pass(a) :: tril        => psb_@LX@_csr_tril
    procedure, pass(a) :: triu        => psb_@LX@_csr_triu
    procedure, pass(a) :: cp_to_coo   => psb_@LX@_cp_csr_to_coo
    procedure, pass(a) :: cp_from_coo => psb_@LX@_cp_csr_from_coo
    procedure, pass(a) :: cp_to_fmt   => psb_@LX@_cp_csr_to_fmt
    procedure, pass(a) :: cp_from_fmt => psb_@LX@_cp_csr_from_fmt
    procedure, pass(a) :: mv_to_coo   => psb_@LX@_mv_csr_to_coo
    procedure, pass(a) :: mv_from_coo => psb_@LX@_mv_csr_from_coo
    procedure, pass(a) :: mv_to_fmt   => psb_@LX@_mv_csr_to_fmt
    procedure, pass(a) :: mv_from_fmt => psb_@LX@_mv_csr_from_fmt
    procedure, pass(a) :: clean_zeros => psb_@LX@_csr_clean_zeros
    procedure, pass(a) :: csput_a     => psb_@LX@_csr_csput_a
    procedure, pass(a) :: get_diag    => psb_@LX@_csr_get_diag
    procedure, pass(a) :: csgetptn    => psb_@LX@_csr_csgetptn
    procedure, pass(a) :: csgetrow    => psb_@LX@_csr_csgetrow
    procedure, pass(a) :: get_nz_row  => @LX@_csr_get_nz_row
    procedure, pass(a) :: reinit      => psb_@LX@_csr_reinit
    procedure, pass(a) :: trim        => psb_@LX@_csr_trim
    procedure, pass(a) :: print       => psb_@LX@_csr_print
    procedure, pass(a) :: free        => @LX@_csr_free
    procedure, pass(a) :: mold        => psb_@LX@_csr_mold
    procedure, pass(a) :: scals       => psb_@LX@_csr_scals
    procedure, pass(a) :: scalv       => psb_@LX@_csr_scal
    procedure, pass(a) :: maxval      => psb_@LX@_csr_maxval
    procedure, pass(a) :: spnmi       => psb_@LX@_csr_csnmi
    procedure, pass(a) :: rowsum      => psb_@LX@_csr_rowsum
    procedure, pass(a) :: arwsum      => psb_@LX@_csr_arwsum
    procedure, pass(a) :: colsum      => psb_@LX@_csr_colsum
    procedure, pass(a) :: aclsum      => psb_@LX@_csr_aclsum

  end type psb_@LX@_csr_sparse_mat

  private :: @LX@_csr_get_nzeros, @LX@_csr_free,  @LX@_csr_get_fmt, &
       & @LX@_csr_get_size, @LX@_csr_sizeof, @LX@_csr_get_nz_row, &
       & @LX@_csr_is_by_rows

  !> \memberof psb_@LX@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_reallocate_nz
  interface
    subroutine  psb_@LX@_csr_reallocate_nz(nz,a)
      import
      integer(@LXKIND@), intent(in) :: nz
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
    end subroutine psb_@LX@_csr_reallocate_nz
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_reinit
  interface
    subroutine psb_@LX@_csr_reinit(a,clear)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      logical, intent(in), optional :: clear
    end subroutine psb_@LX@_csr_reinit
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_trim
  interface
    subroutine  psb_@LX@_csr_trim(a)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
    end subroutine psb_@LX@_csr_trim
  end interface


  !> \memberof psb_@LX@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_mold
  interface
    subroutine psb_@LX@_csr_mold(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in)                  :: a
      class(psb_@LX@_base_sparse_mat), intent(inout), allocatable :: b
      integer(psb_ipk_), intent(out)                           :: info
    end subroutine psb_@LX@_csr_mold
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !| \see psb_base_mat_mod::psb_base_allocate_mnnz
  interface
    subroutine  psb_@LX@_csr_allocate_mnnz(m,n,a,nz)
      import
      integer(@LXKIND@), intent(in) :: m,n
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      integer(@LXKIND@), intent(in), optional :: nz
    end subroutine psb_@LX@_csr_allocate_mnnz
  end interface


  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_print
  interface
    subroutine psb_@LX@_csr_print(iout,a,iv,head,ivr,ivc)
      import
      integer(psb_ipk_), intent(in)               :: iout
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      integer(@LXKIND@), intent(in), optional     :: iv(:)
      character(len=*), optional        :: head
      integer(@LXKIND@), intent(in), optional     :: ivr(:), ivc(:)
    end subroutine psb_@LX@_csr_print
  end interface
  !
  !> Function  tril:
  !! \memberof  psb_@X@_base_sparse_mat
  !! \brief  Copy the lower triangle, i.e. all entries
  !!         A(I,J) such that J-I <= DIAG
  !!         default value is DIAG=0, i.e. lower triangle up to
  !!         the main diagonal.
  !!         DIAG=-1 means copy the strictly lower triangle
  !!         DIAG= 1 means copy the lower triangle plus the first diagonal
  !!                 of the upper triangle.
  !!         Moreover, apply a clipping by copying entries A(I,J) only if
  !!         IMIN<=I<=IMAX
  !!         JMIN<=J<=JMAX
  !!
  !!  \param l     the output (sub)matrix
  !!  \param info  return code
  !!  \param diag [0] the last diagonal (J-I) to be considered.
  !!  \param imin [1] the minimum row index we are interested in
  !!  \param imax [a\%get_nrows()] the minimum row index we are interested in
  !!  \param jmin [1] minimum col index
  !!  \param jmax [a\%get_ncols()] maximum col index
  !!  \param iren(:) [none] an array to return renumbered indices (iren(ia(:)),iren(ja(:))
  !!  \param rscale [false] map [min(ia(:)):max(ia(:))] onto [1:max(ia(:))-min(ia(:))+1]
  !!  \param cscale [false] map [min(ja(:)):max(ja(:))] onto [1:max(ja(:))-min(ja(:))+1]
  !!          ( iren cannot be specified with rscale/cscale)
  !!  \param append [false] append to ia,ja
  !!  \param nzin [none]  if append, then first new entry should go in entry nzin+1
  !!  \param u  [none]  copy of the complementary triangle
  !!
  !
  interface
    subroutine psb_@LX@_csr_tril(a,l,info,diag,imin,imax,&
         & jmin,jmax,rscale,cscale,u)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      class(psb_@LX@_coo_sparse_mat), intent(out) :: l
      integer(psb_ipk_),intent(out)              :: info
      integer(@LXKIND@), intent(in), optional    :: diag,imin,imax,jmin,jmax
      logical, intent(in), optional              :: rscale,cscale
      class(psb_@LX@_coo_sparse_mat), optional, intent(out) :: u
    end subroutine psb_@LX@_csr_tril
  end interface

  !
  !> Function  triu:
  !! \memberof  psb_@X@_csr_sparse_mat
  !! \brief  Copy the upper triangle, i.e. all entries
  !!         A(I,J) such that DIAG <= J-I
  !!         default value is DIAG=0, i.e. upper triangle from
  !!         the main diagonal up.
  !!         DIAG= 1 means copy the strictly upper triangle
  !!         DIAG=-1 means copy the upper triangle plus the first diagonal
  !!                 of the lower triangle.
  !!         Moreover, apply a clipping by copying entries A(I,J) only if
  !!         IMIN<=I<=IMAX
  !!         JMIN<=J<=JMAX
  !!         Optionally copies the lower triangle at the same time
  !!
  !!  \param u     the output (sub)matrix
  !!  \param info  return code
  !!  \param diag [0] the last diagonal (J-I) to be considered.
  !!  \param imin [1] the minimum row index we are interested in
  !!  \param imax [a\%get_nrows()] the minimum row index we are interested in
  !!  \param jmin [1] minimum col index
  !!  \param jmax [a\%get_ncols()] maximum col index
  !!  \param iren(:) [none] an array to return renumbered indices (iren(ia(:)),iren(ja(:))
  !!  \param rscale [false] map [min(ia(:)):max(ia(:))] onto [1:max(ia(:))-min(ia(:))+1]
  !!  \param cscale [false] map [min(ja(:)):max(ja(:))] onto [1:max(ja(:))-min(ja(:))+1]
  !!          ( iren cannot be specified with rscale/cscale)
  !!  \param append [false] append to ia,ja
  !!  \param nzin [none]  if append, then first new entry should go in entry nzin+1
  !!  \param l  [none]  copy of the complementary triangle
  !!
  !
  interface
    subroutine psb_@LX@_csr_triu(a,u,info,diag,imin,imax,&
         & jmin,jmax,rscale,cscale,l)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      class(psb_@LX@_coo_sparse_mat), intent(out) :: u
      integer(psb_ipk_),intent(out)              :: info
      integer(@LXKIND@), intent(in), optional    :: diag,imin,imax,jmin,jmax
      logical, intent(in), optional              :: rscale,cscale
      class(psb_@LX@_coo_sparse_mat), optional, intent(out) :: l
    end subroutine psb_@LX@_csr_triu
  end interface

    !
  !>
  !! \memberof  psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_clean_zeros
  !
  interface
    subroutine  psb_@LX@_csr_clean_zeros(a, info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      integer(psb_ipk_), intent(out)              :: info
    end subroutine psb_@LX@_csr_clean_zeros
  end interface



  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_cp_to_coo
  interface
    subroutine psb_@LX@_cp_csr_to_coo(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      class(psb_@LX@_coo_sparse_mat), intent(inout) :: b
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@LX@_cp_csr_to_coo
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_cp_from_coo
  interface
    subroutine psb_@LX@_cp_csr_from_coo(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      class(psb_@LX@_coo_sparse_mat), intent(in)    :: b
      integer(psb_ipk_), intent(out)               :: info
    end subroutine psb_@LX@_cp_csr_from_coo
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_cp_to_fmt
  interface
    subroutine psb_@LX@_cp_csr_to_fmt(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in)   :: a
      class(psb_@LX@_base_sparse_mat), intent(inout) :: b
      integer(psb_ipk_), intent(out)                       :: info
    end subroutine psb_@LX@_cp_csr_to_fmt
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_cp_from_fmt
  interface
    subroutine psb_@LX@_cp_csr_from_fmt(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      class(psb_@LX@_base_sparse_mat), intent(in)   :: b
      integer(psb_ipk_), intent(out)                        :: info
    end subroutine psb_@LX@_cp_csr_from_fmt
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_mv_to_coo
  interface
    subroutine psb_@LX@_mv_csr_to_coo(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      class(psb_@LX@_coo_sparse_mat), intent(inout)   :: b
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@LX@_mv_csr_to_coo
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_mv_from_coo
  interface
    subroutine psb_@LX@_mv_csr_from_coo(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      class(psb_@LX@_coo_sparse_mat), intent(inout) :: b
      integer(psb_ipk_), intent(out)                        :: info
    end subroutine psb_@LX@_mv_csr_from_coo
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_mv_to_fmt
  interface
    subroutine psb_@LX@_mv_csr_to_fmt(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      class(psb_@LX@_base_sparse_mat), intent(inout)  :: b
      integer(psb_ipk_), intent(out)                        :: info
    end subroutine psb_@LX@_mv_csr_to_fmt
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_mv_from_fmt
  interface
    subroutine psb_@LX@_mv_csr_from_fmt(a,b,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout)  :: a
      class(psb_@LX@_base_sparse_mat), intent(inout) :: b
      integer(psb_ipk_), intent(out)                         :: info
    end subroutine psb_@LX@_mv_csr_from_fmt
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_cp_from
  interface
    subroutine psb_@LX@_csr_cp_from(a,b)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      type(psb_@LX@_csr_sparse_mat), intent(in)   :: b
    end subroutine psb_@LX@_csr_cp_from
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_mv_from
  interface
    subroutine psb_@LX@_csr_mv_from(a,b)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout)  :: a
      type(psb_@LX@_csr_sparse_mat), intent(inout) :: b
    end subroutine psb_@LX@_csr_mv_from
  end interface


  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_csput_a
  interface
    subroutine psb_@LX@_csr_csput_a(nz,ia,ja,val,a,imin,imax,jmin,jmax,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      @TYPE@(@FKIND@), intent(in)      :: val(:)
      integer(@LXKIND@), intent(in)             :: nz,ia(:), ja(:),&
           &  imin,imax,jmin,jmax
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@LX@_csr_csput_a
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_base_mat_mod::psb_base_csgetptn
  interface
    subroutine psb_@LX@_csr_csgetptn(imin,imax,a,nz,ia,ja,info,&
         & jmin,jmax,iren,append,nzin,rscale,cscale)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      integer(@LXKIND@), intent(in)                  :: imin,imax
      integer(@LXKIND@), intent(out)                 :: nz
      integer(@LXKIND@), allocatable, intent(inout)  :: ia(:), ja(:)
      integer(psb_ipk_),intent(out)                  :: info
      logical, intent(in), optional        :: append
      integer(@LXKIND@), intent(in), optional        :: iren(:)
      integer(@LXKIND@), intent(in), optional        :: jmin,jmax, nzin
      logical, intent(in), optional        :: rscale,cscale
    end subroutine psb_@LX@_csr_csgetptn
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_csgetrow
  interface
    subroutine psb_@LX@_csr_csgetrow(imin,imax,a,nz,ia,ja,val,info,&
         & jmin,jmax,iren,append,nzin,rscale,cscale)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      integer(@LXKIND@), intent(in)                  :: imin,imax
      integer(@LXKIND@), intent(out)                 :: nz
      integer(@LXKIND@), allocatable, intent(inout)  :: ia(:), ja(:)
      @TYPE@(@FKIND@), allocatable,  intent(inout)    :: val(:)
      integer(psb_ipk_),intent(out)                  :: info
      logical, intent(in), optional        :: append
      integer(@LXKIND@), intent(in), optional        :: iren(:)
      integer(@LXKIND@), intent(in), optional        :: jmin,jmax, nzin
      logical, intent(in), optional        :: rscale,cscale
    end subroutine psb_@LX@_csr_csgetrow
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_get_diag
  interface
    subroutine psb_@LX@_csr_get_diag(a,d,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(out)     :: d(:)
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@LX@_csr_get_diag
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_scal
  interface
    subroutine psb_@LX@_csr_scal(d,a,info,side)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      @TYPE@(@FKIND@), intent(in)      :: d(:)
      integer(psb_ipk_), intent(out)            :: info
      character, intent(in), optional :: side
    end subroutine psb_@LX@_csr_scal
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@LX@_base_mat_mod::psb_@LX@_base_scals
  interface
    subroutine psb_@LX@_csr_scals(d,a,info)
      import
      class(psb_@LX@_csr_sparse_mat), intent(inout) :: a
      @TYPE@(@FKIND@), intent(in)      :: d
      integer(psb_ipk_), intent(out)            :: info
    end subroutine psb_@LX@_csr_scals
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@LX@_base_maxval
  interface
    function psb_@LX@_csr_maxval(a) result(res)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      @RTYPE@(@FKIND@)         :: res
    end function psb_@LX@_csr_maxval
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@LX@_base_csnmi
  interface
    function psb_@LX@_csr_csnmi(a) result(res)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      @RTYPE@(@FKIND@)         :: res
    end function psb_@LX@_csr_csnmi
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@LX@_base_rowsum
  interface
    subroutine psb_@LX@_csr_rowsum(d,a)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(out)              :: d(:)
    end subroutine psb_@LX@_csr_rowsum
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@LX@_base_arwsum
  interface
    subroutine psb_@LX@_csr_arwsum(d,a)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      @RTYPE@(@FKIND@), intent(out)              :: d(:)
    end subroutine psb_@LX@_csr_arwsum
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@LX@_base_colsum
  interface
    subroutine psb_@LX@_csr_colsum(d,a)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      @TYPE@(@FKIND@), intent(out)              :: d(:)
    end subroutine psb_@LX@_csr_colsum
  end interface

  !> \memberof psb_@LX@_csr_sparse_mat
  !! \see psb_@X@_base_mat_mod::psb_@LX@_base_aclsum
  interface
    subroutine psb_@LX@_csr_aclsum(d,a)
      import
      class(psb_@LX@_csr_sparse_mat), intent(in) :: a
      @RTYPE@(@FKIND@), intent(out)              :: d(:)
    end subroutine psb_@LX@_csr_aclsum
  end interface


contains

  ! == ===================================
  !
  !
  !
  ! Getters
  !
  !
  !
  !
  !
  ! == ===================================



  function @X@_csr_is_by_rows(a) result(res)
    implicit none
    class(psb_@X@_csr_sparse_mat), intent(in) :: a
    logical  :: res
    res = .true.

  end function @X@_csr_is_by_rows


  function @X@_csr_sizeof(a) result(res)
    implicit none
    class(psb_@X@_csr_sparse_mat), intent(in) :: a
    integer(psb_epk_) :: res
    res = 2 * psb_sizeof_ip
    res = res + @SIZET@  * psb_size(a%val)
    res = res + psb_sizeof_ip * psb_size(a%irp)
    res = res + psb_sizeof_ip * psb_size(a%ja)

  end function @X@_csr_sizeof

  function @X@_csr_get_fmt() result(res)
    implicit none
    character(len=5) :: res
    res = 'CSR'
  end function @X@_csr_get_fmt

  function @X@_csr_get_nzeros(a) result(res)
    implicit none
    class(psb_@X@_csr_sparse_mat), intent(in) :: a
    integer(@IXKIND@) :: res
    res = a%irp(a%get_nrows()+1)-1
  end function @X@_csr_get_nzeros

  function @X@_csr_get_size(a) result(res)
    implicit none
    class(psb_@X@_csr_sparse_mat), intent(in) :: a
    integer(@IXKIND@) :: res

    res = -1

    if (allocated(a%ja)) then
      res = size(a%ja)
    end if
    if (allocated(a%val)) then
      if (res >= 0) then
        res = min(res,size(a%val))
      else
        res = size(a%val)
      end if
    end if

  end function @X@_csr_get_size



  function  @X@_csr_get_nz_row(idx,a) result(res)

    implicit none

    class(psb_@X@_csr_sparse_mat), intent(in) :: a
    integer(@IXKIND@), intent(in)                  :: idx
    integer(@IXKIND@) :: res

    res = 0

    if ((1<=idx).and.(idx<=a%get_nrows())) then
      res = a%irp(idx+1)-a%irp(idx)
    end if

  end function @X@_csr_get_nz_row



  ! == ===================================
  !
  !
  !
  ! Data management
  !
  !
  !
  !
  !
  ! == ===================================

  subroutine  @X@_csr_free(a)
    implicit none

    class(psb_@X@_csr_sparse_mat), intent(inout) :: a

    if (allocated(a%irp)) deallocate(a%irp)
    if (allocated(a%ja)) deallocate(a%ja)
    if (allocated(a%val)) deallocate(a%val)
    call a%set_null()
    call a%set_nrows(0_@IXKIND@)
    call a%set_ncols(0_@IXKIND@)

    return

  end subroutine @X@_csr_free



  ! == ===================================
  !
  !
  !
  ! Getters
  !
  !
  !
  !
  !
  ! == ===================================



  function @LX@_csr_is_by_rows(a) result(res)
    implicit none
    class(psb_@LX@_csr_sparse_mat), intent(in) :: a
    logical  :: res
    res = .true.

  end function @LX@_csr_is_by_rows


  function @LX@_csr_sizeof(a) result(res)
    implicit none
    class(psb_@LX@_csr_sparse_mat), intent(in) :: a
    integer(psb_epk_) :: res
    res = 2 * psb_sizeof_lp
    res = res + @SIZET@  * psb_size(a%val)
    res = res + psb_sizeof_lp * psb_size(a%irp)
    res = res + psb_sizeof_lp * psb_size(a%ja)

  end function @LX@_csr_sizeof

  function @LX@_csr_get_fmt() result(res)
    implicit none
    character(len=5) :: res
    res = 'CSR'
  end function @LX@_csr_get_fmt

  function @LX@_csr_get_nzeros(a) result(res)
    implicit none
    class(psb_@LX@_csr_sparse_mat), intent(in) :: a
    integer(@LXKIND@) :: res
    res = a%irp(a%get_nrows()+1)-1
  end function @LX@_csr_get_nzeros

  function @LX@_csr_get_size(a) result(res)
    implicit none
    class(psb_@LX@_csr_sparse_mat), intent(in) :: a
    integer(@LXKIND@) :: res

    res = -1

    if (allocated(a%ja)) then
      res = size(a%ja)
    end if
    if (allocated(a%val)) then
      if (res >= 0) then
        res = min(res,size(a%val))
      else
        res = size(a%val)
      end if
    end if

  end function @LX@_csr_get_size



  function  @LX@_csr_get_nz_row(idx,a) result(res)

    implicit none

    class(psb_@LX@_csr_sparse_mat), intent(in) :: a
    integer(@LXKIND@), intent(in)                  :: idx
    integer(@LXKIND@) :: res

    res = 0

    if ((1<=idx).and.(idx<=a%get_nrows())) then
      res = a%irp(idx+1)-a%irp(idx)
    end if

  end function @LX@_csr_get_nz_row



  ! == ===================================
  !
  !
  !
  ! Data management
  !
  !
  !
  !
  !
  ! == ===================================

  subroutine  @LX@_csr_free(a)
    implicit none

    class(psb_@LX@_csr_sparse_mat), intent(inout) :: a

    if (allocated(a%irp)) deallocate(a%irp)
    if (allocated(a%ja)) deallocate(a%ja)
    if (allocated(a%val)) deallocate(a%val)
    call a%set_null()
    call a%set_nrows(0_@LXKIND@)
    call a%set_ncols(0_@LXKIND@)

    return

  end subroutine @LX@_csr_free

end module psb_@X@_csr_mat_mod
